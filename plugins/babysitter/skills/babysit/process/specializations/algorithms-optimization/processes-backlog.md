# Algorithms and Optimization Processes Backlog

This backlog contains processes, methodologies, work patterns, and flows for the Algorithms and Optimization specialization.

## Process Categories

### Competitive Programming Practice

- [ ] **LeetCode Problem-Solving Session**
  - Description: Structured process for solving LeetCode problems with time constraints, including problem analysis, complexity analysis, implementation, testing, and optimization iterations
  - References: LeetCode patterns, problem classification, complexity analysis
  - Tools: LeetCode platform, local IDE, time tracker
  - Outputs: Solution code, complexity analysis, pattern recognition notes, test cases

- [ ] **Codeforces Contest Preparation and Participation**
  - Description: End-to-end process for Codeforces contest preparation including virtual contest practice, upsolving, rating improvement tracking, and pattern mastery
  - References: Codeforces problem ratings, competitive programming handbook
  - Tools: Codeforces platform, C++ template, stress testing tools
  - Outputs: Contest solutions, upsolving notes, rating progress tracking, weak area identification

- [ ] **AtCoder Contest Practice and Analysis**
  - Description: Process for participating in AtCoder contests with focus on problem-solving speed, accuracy, and post-contest editorial analysis
  - References: AtCoder problem difficulty progression, Japanese CP community resources
  - Tools: AtCoder platform, online IDE, competitive programming library
  - Outputs: Contest submissions, editorial summaries, algorithm implementations

- [ ] **CSES Problem Set Systematic Learning Path**
  - Description: Structured approach to completing the CSES problem set (300 problems) covering all algorithm topics systematically with tracking and mastery verification
  - References: CSES problem set, Competitive Programmer's Handbook
  - Tools: CSES platform, local development environment
  - Outputs: Problem solutions, topic mastery checklist, algorithm implementations

- [ ] **Problem Pattern Recognition and Classification**
  - Description: Process for analyzing problem statements, identifying patterns (two-pointer, sliding window, DP, greedy, graph), and selecting appropriate algorithms based on constraints
  - References: Problem-solving patterns, constraint-to-algorithm mapping
  - Tools: Pattern recognition frameworks, problem categorization tools
  - Outputs: Pattern identification guide, constraint analysis, algorithm selection strategy

### Algorithm Implementation and Library Building

- [ ] **Algorithm Implementation from Scratch**
  - Description: Process for implementing classic algorithms from pseudocode/description with correctness proofs, complexity analysis, testing with edge cases, and optimization
  - References: CLRS, Algorithm Design Manual, CP-Algorithms
  - Tools: C++/Python/Java, unit testing frameworks, benchmarking tools
  - Outputs: Correct implementation, test suite, complexity analysis, documentation

- [ ] **Competitive Programming Library Creation**
  - Description: Building a personal algorithm library with template implementations of common algorithms, data structures, and patterns for quick contest usage
  - References: C++ STL, competitive programming templates
  - Tools: Git, C++ templates, snippet managers
  - Outputs: Algorithm library, template code, usage examples, quick reference

- [ ] **Data Structure Implementation and Verification**
  - Description: Process for implementing advanced data structures (segment tree, fenwick tree, trie, union-find) with operation verification and performance benchmarking
  - References: Data structure references, implementation guides
  - Tools: C++, testing frameworks, visualization tools
  - Outputs: Data structure implementations, test cases, performance benchmarks

- [ ] **Algorithm Correctness Proof and Testing**
  - Description: Formal process for proving algorithm correctness using invariants, induction, and contradiction, followed by comprehensive testing including edge cases
  - References: Proof techniques, correctness verification methods
  - Tools: Formal methods tools, test case generators
  - Outputs: Correctness proof, test cases, edge case analysis

### Dynamic Programming Mastery

- [ ] **DP Problem Identification and Pattern Matching**
  - Description: Process for recognizing DP problems, identifying subproblems, finding optimal substructure, and selecting appropriate DP pattern (linear, 2D, interval, tree, bitmask)
  - References: DP patterns, classic DP problems, state design
  - Tools: DP pattern library, state transition visualizer
  - Outputs: Problem classification, state definition, transition formula, implementation

- [ ] **DP State Design and Optimization**
  - Description: Systematic approach to designing DP states, optimizing space complexity (rolling array, state compression), and improving time complexity using optimization techniques
  - References: DP optimization techniques, space-time tradeoffs
  - Tools: State space analyzer, complexity calculator
  - Outputs: Optimal state design, space-optimized solution, complexity analysis

- [ ] **DP Transition Formula Derivation**
  - Description: Process for deriving recurrence relations, establishing base cases, and implementing memoization or tabulation approaches with correctness verification
  - References: Recurrence relations, DP implementation patterns
  - Tools: Formula derivation tools, implementation templates
  - Outputs: Recurrence formula, base cases, implementation, verification

- [ ] **Classic DP Problem Library Building**
  - Description: Comprehensive process for solving and documenting classic DP problems (knapsack, LCS, edit distance, matrix chain, coin change) with multiple approaches
  - References: Classic DP problem collection, solution variations
  - Tools: Problem database, solution templates
  - Outputs: Problem solutions, approach comparisons, complexity analysis, pattern library

### Graph Algorithm Applications

- [ ] **Graph Problem Modeling and Representation**
  - Description: Process for converting real-world problems into graph representations, selecting appropriate graph structure (directed/undirected, weighted/unweighted), and choosing adjacency list vs matrix
  - References: Graph theory fundamentals, problem modeling techniques
  - Tools: Graph visualization tools, modeling frameworks
  - Outputs: Graph model, representation choice justification, implementation

- [ ] **Shortest Path Algorithm Selection and Implementation**
  - Description: Systematic process for selecting shortest path algorithm (Dijkstra, Bellman-Ford, Floyd-Warshall, A*) based on constraints, implementing, and verifying correctness
  - References: Shortest path algorithms, complexity analysis
  - Tools: Graph libraries, pathfinding visualization
  - Outputs: Algorithm implementation, path reconstruction, complexity analysis

- [ ] **Graph Traversal and Connectivity Analysis**
  - Description: Process for implementing DFS/BFS for various applications (cycle detection, topological sort, connected components, bipartite checking, shortest paths)
  - References: Graph traversal algorithms, traversal applications
  - Tools: Graph traversal templates, visualization tools
  - Outputs: Traversal implementations, application solutions, complexity analysis

- [ ] **Advanced Graph Algorithm Implementation**
  - Description: Implementation of advanced graph algorithms including maximum flow (Dinic's, Edmonds-Karp), minimum spanning tree (Kruskal, Prim), and bipartite matching (Hopcroft-Karp)
  - References: Network flow algorithms, MST algorithms, matching algorithms
  - Tools: Advanced graph libraries, flow visualization
  - Outputs: Algorithm implementations, application examples, performance analysis

### Optimization and Performance Engineering

- [ ] **Algorithm Complexity Analysis and Optimization**
  - Description: Process for analyzing time/space complexity, identifying bottlenecks, and optimizing algorithms through better algorithmic approaches, not just code-level optimization
  - References: Big-O analysis, complexity theory, optimization techniques
  - Tools: Profilers, complexity analyzers, benchmarking tools
  - Outputs: Complexity analysis, bottleneck identification, optimized solution

- [ ] **Code-Level Performance Optimization**
  - Description: Micro-optimization process including cache optimization, avoiding redundant computation, using appropriate data structures, and language-specific optimizations
  - References: Performance optimization guides, cache efficiency, language-specific tricks
  - Tools: Profilers (perf, gprof, Valgrind), benchmarking frameworks
  - Outputs: Optimized code, performance comparison, optimization report

- [ ] **I/O Optimization for Competitive Programming**
  - Description: Process for implementing fast I/O techniques (C++ sync_with_stdio, cin.tie, Python sys.stdin, Java BufferedReader) and batch processing for large inputs
  - References: Fast I/O techniques, competitive programming tricks
  - Tools: I/O benchmarking, input generators
  - Outputs: Fast I/O templates, performance benchmarks

- [ ] **Memory Optimization and Space Complexity Reduction**
  - Description: Systematic approach to reducing space complexity through rolling arrays, in-place algorithms, bit manipulation, and space-efficient data structures
  - References: Space optimization techniques, memory-efficient algorithms
  - Tools: Memory profilers, space analyzers
  - Outputs: Space-optimized solution, memory usage comparison

### String Algorithm Applications

- [ ] **Pattern Matching Algorithm Implementation**
  - Description: Process for implementing and comparing pattern matching algorithms (KMP, Rabin-Karp, Boyer-Moore, Z-algorithm) with performance analysis
  - References: String matching algorithms, pattern matching techniques
  - Tools: String algorithm libraries, pattern matching benchmarks
  - Outputs: Algorithm implementations, performance comparison, use case analysis

- [ ] **Trie and Suffix Structure Building**
  - Description: Implementation of trie, suffix array, and suffix tree with applications to pattern matching, autocomplete, and string processing problems
  - References: Trie construction, suffix array algorithms, suffix tree
  - Tools: String structure libraries, visualization tools
  - Outputs: Structure implementations, application examples, complexity analysis

- [ ] **String Processing Problem Solving**
  - Description: Comprehensive process for solving string problems including palindromes (Manacher's), longest common subsequence, edit distance, and string transformations
  - References: String algorithm catalog, classic string problems
  - Tools: String processing libraries, algorithm templates
  - Outputs: Problem solutions, algorithm applications, pattern recognition

### Number Theory and Mathematical Algorithms

- [ ] **Modular Arithmetic and Number Theory Implementation**
  - Description: Process for implementing GCD/LCM (Euclidean algorithm), modular exponentiation, modular inverse, and solving number theory problems
  - References: Number theory algorithms, modular arithmetic
  - Tools: Mathematical computation libraries, primality testing tools
  - Outputs: Number theory implementations, problem solutions

- [ ] **Prime Number Algorithms and Applications**
  - Description: Implementation of sieve of Eratosthenes, primality testing (Miller-Rabin), prime factorization, and applications to competitive programming problems
  - References: Prime number algorithms, factorization techniques
  - Tools: Prime generators, factorization libraries
  - Outputs: Prime algorithms, application solutions, performance analysis

- [ ] **Combinatorics and Counting Problem Solving**
  - Description: Process for solving counting problems using permutations, combinations, binomial coefficients, Catalan numbers, and inclusion-exclusion principle
  - References: Combinatorics formulas, counting techniques
  - Tools: Combinatorics calculators, formula libraries
  - Outputs: Counting problem solutions, formula applications

### Interview Preparation

- [ ] **FAANG Interview Problem Practice Session**
  - Description: Structured interview practice including problem statement clarification, brute force approach, optimization, implementation, testing, and complexity analysis with communication
  - References: Cracking the Coding Interview, LeetCode interview patterns
  - Tools: Mock interview platforms, whiteboard tools, time tracking
  - Outputs: Problem solutions, approach explanations, complexity analysis, interview performance notes

- [ ] **Interview Problem Pattern Mastery**
  - Description: Systematic study of interview patterns (two pointers, sliding window, fast/slow pointer, merge intervals, topological sort) with problem categorization and solving
  - References: LeetCode patterns, interview problem classification
  - Tools: Pattern library, problem categorization tools
  - Outputs: Pattern recognition guide, solved problems by pattern, quick reference

- [ ] **Mock Interview with Feedback Loop**
  - Description: Complete mock interview process including coding, communication, testing, optimization, followed by detailed feedback analysis and improvement plan
  - References: Mock interview best practices, feedback frameworks
  - Tools: Pramp, Interviewing.io, peer mock interviews
  - Outputs: Interview recording, feedback notes, improvement action plan

- [ ] **System Design with Algorithmic Considerations**
  - Description: Process for tackling system design interviews with focus on algorithmic aspects (caching strategies, consistent hashing, rate limiting algorithms, data structure selection)
  - References: System design interview resources, algorithmic system components
  - Tools: System design tools, architecture diagramming
  - Outputs: System design document, algorithmic choices, trade-off analysis

### Contest Strategy and Performance

- [ ] **Contest Time Management and Problem Selection**
  - Description: Strategy development for contest participation including problem reading, difficulty estimation, problem ordering, time allocation, and when to skip problems
  - References: Contest strategy guides, rating improvement techniques
  - Tools: Time tracking, problem difficulty estimators
  - Outputs: Contest strategy document, problem selection criteria, time management plan

- [ ] **Contest Debugging and Testing Strategy**
  - Description: Systematic approach to debugging during contests including test case generation, edge case identification, stress testing, and debugging techniques under time pressure
  - References: Debugging strategies, test case generation techniques
  - Tools: Test generators, stress testing tools, debug templates
  - Outputs: Debugging checklist, test case templates, stress testing scripts

- [ ] **Upsolving and Learning from Contest Problems**
  - Description: Post-contest process for upsolving unsolved problems, reading editorials, understanding alternative approaches, and identifying knowledge gaps
  - References: Editorial analysis, upsolving strategies
  - Tools: Editorial readers, solution comparators
  - Outputs: Upsolving solutions, learning notes, weak area identification

### Advanced Algorithm Topics

- [ ] **Segment Tree and Fenwick Tree Mastery**
  - Description: Complete process for implementing segment trees with lazy propagation, Fenwick trees, and solving range query problems with various operations (sum, min, max, GCD)
  - References: Segment tree tutorial, Fenwick tree implementation, lazy propagation
  - Tools: Data structure libraries, range query visualizers
  - Outputs: Data structure implementations, range query solutions, performance analysis

- [ ] **Advanced Dynamic Programming Techniques**
  - Description: Learning and implementing advanced DP techniques including bitmask DP, digit DP, DP on trees, DP optimization (convex hull trick, divide and conquer optimization)
  - References: Advanced DP tutorials, optimization techniques
  - Tools: DP optimization tools, state space analyzers
  - Outputs: Advanced DP implementations, optimization examples, complexity improvements

- [ ] **Computational Geometry Problem Solving**
  - Description: Process for solving geometry problems including convex hull (Graham scan), line intersection, closest pair of points, and geometric algorithms
  - References: Computational geometry algorithms, geometry problem patterns
  - Tools: Geometry libraries, visualization tools
  - Outputs: Geometry algorithm implementations, problem solutions

- [ ] **Flow and Matching Algorithm Applications**
  - Description: Implementation of maximum flow algorithms (Ford-Fulkerson, Edmonds-Karp, Dinic's), minimum cost flow, and bipartite matching with real-world applications
  - References: Network flow algorithms, flow applications
  - Tools: Flow libraries, network visualization
  - Outputs: Flow algorithm implementations, application examples, complexity analysis

### Skill Development and Career

- [ ] **Algorithm Portfolio and GitHub Library Building**
  - Description: Process for creating a comprehensive algorithm portfolio on GitHub with well-documented implementations, test cases, complexity analysis, and usage examples
  - References: Portfolio best practices, documentation standards
  - Tools: Git, GitHub, documentation generators
  - Outputs: GitHub repository, algorithm library, documentation, README

- [ ] **Technical Blog Writing for Algorithms**
  - Description: Process for writing technical blog posts explaining algorithms, problem-solving approaches, and insights with clear explanations, visualizations, and code examples
  - References: Technical writing best practices, algorithm explanation techniques
  - Tools: Blog platforms, diagram tools, code formatters
  - Outputs: Blog posts, algorithm explanations, visualizations

- [ ] **Algorithm Teaching and Mentoring Process**
  - Description: Structured approach to teaching algorithms including curriculum design, problem selection, explanation techniques, code review, and student progress tracking
  - References: Teaching methodologies, curriculum design
  - Tools: Educational platforms, code review tools
  - Outputs: Curriculum, teaching materials, problem sets, student progress reports

### Benchmarking and Analysis

- [ ] **Algorithm Performance Benchmarking**
  - Description: Comprehensive benchmarking process including test data generation, multiple implementation comparison, time/space measurement, and statistical analysis
  - References: Benchmarking methodologies, statistical analysis
  - Tools: Benchmarking frameworks, profilers, statistical tools
  - Outputs: Benchmark results, performance comparison, statistical analysis

- [ ] **Complexity Analysis and Verification**
  - Description: Process for theoretically analyzing complexity and empirically verifying through testing with increasing input sizes, plotting growth curves, and confirming Big-O behavior
  - References: Complexity theory, empirical analysis techniques
  - Tools: Complexity analyzers, plotting tools, test generators
  - Outputs: Complexity proof, empirical verification, growth curve plots

### Problem Creation and Contribution

- [ ] **Competitive Programming Problem Setting**
  - Description: End-to-end process for creating competitive programming problems including idea generation, problem statement writing, test case generation, editorial writing, and difficulty calibration
  - References: Problem setting guidelines, testlib framework
  - Tools: Polygon, testlib, test generators, validators
  - Outputs: Problem statement, test cases, editorial, validator, checker

- [ ] **Open Source Algorithm Contribution**
  - Description: Process for contributing to open-source algorithm libraries including implementation, testing, documentation, benchmarking, and pull request submission
  - References: Open source contribution guidelines, code quality standards
  - Tools: Git, GitHub, testing frameworks, documentation tools
  - Outputs: Pull request, implementation, tests, documentation

## Summary

**Total Processes Identified: 40**

**Categories:**
- Competitive Programming Practice (5 processes)
- Algorithm Implementation and Library Building (4 processes)
- Dynamic Programming Mastery (4 processes)
- Graph Algorithm Applications (4 processes)
- Optimization and Performance Engineering (4 processes)
- String Algorithm Applications (3 processes)
- Number Theory and Mathematical Algorithms (3 processes)
- Interview Preparation (4 processes)
- Contest Strategy and Performance (3 processes)
- Advanced Algorithm Topics (4 processes)
- Skill Development and Career (3 processes)
- Benchmarking and Analysis (2 processes)
- Problem Creation and Contribution (2 processes)

## Next Steps

Phase 3 will involve creating JavaScript process files for each identified process using the Babysitter SDK patterns, including:
- Process definitions with inputs/outputs
- Task definitions (node, agent, skill tasks)
- Quality gates and validation steps
- Iterative refinement loops where applicable
- Integration with competitive programming platforms
- Automated testing and verification
- Performance benchmarking and optimization loops
